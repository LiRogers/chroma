% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scale_brewer.R
\name{brewer_scale}
\alias{brewer.colors}
\alias{brewer_colors}
\alias{brewer_map}
\alias{brewer_palette}
\alias{brewer_scale}
\title{ColorBrewer scales and palettes}
\usage{
brewer_scale(name = "Blues", model = "lab", interp = "linear",
  domain = c(0, 1), reverse = FALSE)

brewer_palette(name = "Blues", ...)

brewer_colors(n, name = "Blues", ...)

brewer.colors(n, name = "Blues", ...)

brewer_map(x, ...)
}
\arguments{
\item{name}{name of a ColorBrewer palette. See \code{\link{brewer_info}} for a list of palettes and their characteristics.}

\item{model}{color space in which to perform the interpolation; valid models are \code{lab} (the default and usually most suitable), \code{rgb}, \code{hsv}, \code{hsl}, \code{hcl}, \code{lch}. Beware that all but \code{lab} and \code{rgb} can give surprising results.}

\item{interp}{type of interpolation to perform; either \code{linear} (the default) or \code{bezier}, which results in a smoother transition between colors. \code{bezier} interpolation is only available with \code{model="lab"} however.}

\item{domain}{the values between which the scale is computed.}

\item{reverse}{whether to reverse the order of colors along the scale.}

\item{...}{passed to \code{\link{brewer_scale}}. Note that argument \code{domain} is meaningless in functions other than \code{brewer_scale} and passing it through \code{...} is an error.}

\item{n}{number of colors to extract from the color palette.}

\item{x}{a vector whose values will be coerced to numbers and mapped to colors.}
}
\value{
\code{*_scale} and \code{*_palette} return a function.

\code{*_colors}, \code{*.colors}, and \code{*_map} return a vector of hex colors.
}
\description{
ColorBrewer scales and palettes
}
\details{
The \code{*_scale} version creates a \strong{function} that takes a single argument (\code{x}: a numeric vector), maps the values to colors along an interpolated gradient and returns those colors as hex codes.

The \code{*_palette} version also creates a \strong{function}, but it takes an integer, \code{n}, as argument, picks \code{n} colors evenly spaced along the scale and returns them as hex codes.

The \code{*_colors} and \code{*.colors} versions are just shortcuts for \code{*_palette()(n)} and directly return \code{n} evenly spaced colors. They are equivalent to builtin functions such as \code{\link[grDevices]{heat.colors}}, \code{\link[grDevices]{topo.colors}}, etc.

The \code{*_map} version is also a shortcut, which automatically creates a scale that spans all values in its argument \code{x}, maps the content of \code{x} on that scale and returns the colors. It is particularly useful as the \code{col} argument of plotting functions.
}
\examples{
# define a scale function
ygb <- brewer_scale(name="YlGnBu")
ygb(c(0, 0.2, 0.6, 1))

# define a palette function
bgy_pal <- brewer_palette(name="YlGnBu", reverse=TRUE)
bgy_pal(10)
show_col(bgy_pal(100))

# show 7 colors from each palette
show_col(lapply(brewer_info$name, function(x) {brewer.colors(n=7, name=x)}))

# warn about potentially inappropriate use of many colors
brewer.colors(n=15, name="Blues")
brewer.colors(n=15, name="Pastel1")
brewer_palette(name="Pastel1")(15)
# avoid some warnings by explicitly requiring a continuous palette
brewer_palette(name="Blues")(15)
brewer_palette(name="Pastel1")(15)

x <- 10*(1:nrow(volcano))
y <- 10*(1:ncol(volcano))

image(x, y, volcano, col=make_colors(100, colors=maunga))

persp(x, y, volcano, theta=60, phi=25,
      col=make_map(volcano[-1,-1], colors=maunga))
# NB: This is cheating, colouring each facet according to the value of
#     its lower right point. The correct way is:
persp(x, y, volcano, theta=60, phi=25,
      col=make_map(persp_facets(volcano), colors=maunga))

\dontrun{
library("rgl")
persp3d(x, y, volcano, aspect=c(1,0.6,0.3), axes=FALSE, box=FALSE,
        col=make_map(volcano, colors=maunga))

}
# color points according to a discrete variable
attach(iris)
plot(Petal.Length, Sepal.Length, pch=21, cex=2, bg=make_map(Species))
legend(1, 8, legend=levels(Species), pch=21, pt.bg=make_colors(n=nlevels(Species)))
# NB: works, but a continuous scale is not really appropriate here.

x <- 10*(1:nrow(volcano))
y <- 10*(1:ncol(volcano))
image(x, y, volcano, col=brewer_palette("YlOrBr", reverse=T)(100))
persp(x, y, volcano, theta=60, phi=25,
      col=brewer_map(persp_facets(volcano), "YlOrBr", reverse=TRUE))
\dontrun{
library("rgl")
persp3d(x, y, volcano, aspect=c(1,0.6,0.3), axes=FALSE, box=FALSE,
        col=brewer_map(volcano, "YlOrBr", reverse=TRUE))

}
# color points according to a discrete variable
attach(iris)
plot(Petal.Length, Sepal.Length, pch=19, cex=2, col=brewer_map(Species, "Set2"))
legend(1, 8, legend=levels(Species), pch=19, col=brewer_colors(n=nlevels(Species), name="Set2"))

}
\seealso{
Other color scales and palettes: \code{\link{make_scale}}
}

