% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scales.R
\name{make_scale}
\alias{make.colors}
\alias{make_colors}
\alias{make_palette}
\alias{make_scale}
\title{Create color scales and palettes}
\usage{
make_scale(colors = c("white", "black"), model = "lab", interp = "linear",
  domain = c(0, 1), reverse = FALSE, values = NULL)

make_palette(colors = c("white", "black"), model = "lab",
  interp = "linear", reverse = FALSE, values = NULL)

make_colors(n, ...)

make.colors(n, ...)
}
\arguments{
\item{colors}{vector of colors specified as hex strings or named R colors. By default, those colors will be evenly distributed along the scale and new colors will be interpolated between them.}

\item{model}{color space in which to perform the interpolation; valid models are \code{lab} (the default and usually most suitable), \code{rgb}, \code{hsv}, \code{hsl}, \code{hcl}, \code{lch}. Beware that all but \code{lab} and \code{rgb} can give surprising results.}

\item{interp}{type of interpolation to perform; either \code{linear} (the default) or \code{bezier}, which results in a smoother transition between colors. \code{bezier} interpolation is only available with \code{model="lab"} however.}

\item{domain}{the values between which the scale is computed.}

\item{reverse}{whether to reverse the order of colors along the scale.}

\item{values}{if colours should not be evenly positioned along the gradient this vector gives the position for each color in the \code{colors} vector. This argument supersedes \code{domain} and \code{reverse} because it defines the bounds and order of the color scale.}

\item{n}{number of colors to extract from the color palette.}

\item{...}{passed to \code{\link{make_scale}}.}
}
\value{
The \code{*_scale} version returns a function that takes \code{x}, a numeric vector, as argument, maps the values to colors along the interpolated gradient and returns those colors as hex codes.

The \code{*_palette} version returns a function that takes \code{n}, an integer number, as argument, picks \code{n} colors evenly along the scale and returns them as hex codes.

The \code{*_colors} and \code{*.colors} versions are just shortcuts for \code{*_palette()(n)} and directly return \code{n} colors evenly spaced along the scale, as hex codes. It is meant to be equivalent to builtin functions such as \code{\link[grDevices]{heat.colors}}, \code{\link[grDevices]{topo.colors}}, etc.
}
\description{
Create a color scale (map between numerical values and colors), a color palette (collection of colors) or get a few colors from a palette.
}
\examples{
# define a color scale
coldhot_scale <- make_scale(c("cornflowerblue", "brown3"))
# apply it to some data
coldhot_scale(c(0, 0.2, 0.6, 1))
# for values outside the range, the extreme color of scale is returned
coldhot_scale(1.3)

# define a palette
coldhot_pal <- make_palette(c("cornflowerblue", "brown3"))
# get 10 colors from it
coldhot_pal(10)
show_col(coldhot_pal(10))

# shortcut to define a palette and extract n colors from it
show_col(make.colors(n=50, colors=c("cornflowerblue", "brown3")))

# test interpolation spaces and types
cols <- c("yellow", "blue", "red")
show_col(
   make_palette(cols, model="lab")(10),
   make_palette(cols, model="lab", interp="bez")(10),
   make_palette(cols, model="rgb")(10),
   make_palette(cols, model="hsv")(10),
   make_palette(cols, model="hcl")(10)
)

# change mapping
x <- 0:10
cols <- c("aliceblue", "cornflowerblue", "dodgerblue4")
show_col(
   make_scale(cols)(x),
   make_scale(cols, domain=range(x))(x),
   make_scale(cols, domain=range(x), rev=TRUE)(x),
   make_scale(cols, values=c(0,1,10))(x)
)

}

