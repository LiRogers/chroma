% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scale_light.R
\name{light_scale}
\alias{light_scale}
\alias{light_map}
\alias{light_palette}
\alias{light_colors}
\title{Lightness scale and palette}
\usage{
light_scale(l = c(0, 0.9), c = 0.5, h = 0, domain = c(0, 1),
  reverse = FALSE)

light_map(x, ...)

light_palette(...)

light_colors(n, ...)
}
\arguments{
\item{l}{lightness, number in \code{[0, 1]}; 0 is darkest, 1 is brightest.}

\item{c}{chromacity, number in \code{[0, ~1]}; 0 is grey, ~1 is full color.}

\item{h}{hue, either an angle around the color wheel, in [0, 360] (angles outside of the range are rotated back to within [0, 360]: 380 = 20, -15 = 345, etc.), or a color (hex or named) from which the hue is extracted (by function \code{\link{hue}}).}

\item{domain}{the values between which the scale is computed.}

\item{reverse}{whether to reverse the order of colors along the scale.}

\item{x}{a vector whose values will be coerced to numbers and mapped to colors.}

\item{...}{passed to \code{\link{light_scale}}. Note that argument \code{domain} is meaningless in functions other than \code{light_scale} and passing it through \code{...} is an error.}

\item{n}{number of colors to extract from the color palette.}
}
\value{
\code{*_scale} and \code{*_palette} return a function.

\code{*_map} and \code{*_colors} return a vector of hex colors.
}
\description{
Lightness-based color scale and palette in HCL space.
}
\details{
In HCL space, the perceived color (hue) is completely separated from the perceived intensity (chromacity) and lightness of the color. This means that colors of various hues but same chromacity and lightness appear as the exact same grey when converted to greyscale. This makes the HCL space particularly suitable to create good color palettes:
\itemize{
  \item For qualitative palettes (discrete variables): varying \code{h} at constant \code{c} and \code{l} avoids drawing attention to certain hues, as would happen if the same was done in HSV or HSL space. Indeed, some hues are perceived as brighter (yellow, light green, etc.), others as duller/darker (blues, etc.).
  \item For sequential palettes (continuous variables): varying \code{l} (or possibly \code{c}) for a constant \code{h} gives a sense of direction and avoid the many perceptual pitfalls typical of 'rainbow'-like scales.
}

As a user, the most useful functions are \code{*_map} and \code{*_colors}.

\code{*_scale} creates a \strong{function} that takes a single argument (\code{x}: a numeric vector), maps its values to colors, and returns those colors as hex codes.

\code{*_map} is a shortcut for \code{*_scale(domain=range(x))(x)}: it creates a scale that spans all values in its argument \code{x}, maps the content of \code{x} on that scale, and returns the colors. It is particularly useful as the \code{col} argument of plotting functions.

\code{*_palette} also creates a \strong{function}, but this one takes an integer (\code{n}) as argument, picks \code{n} colors evenly spaced along the scale, and returns them as hex codes.

\code{*_colors} is a shortcut for \code{*_palette()(n)} and directly returns \code{n} evenly spaced colors. It is equivalent to built-in functions such as \code{\link[grDevices]{heat.colors}}, \code{\link[grDevices]{topo.colors}}, etc.
}
\examples{
# Define a dark-to-light blue scale
blues <- light_scale(h=220)
# and apply it to some data
blues(x=c(0, 0.2, 0.6, 1))

# Define a palette function
# (which works like the actual rainbow() function)
blues_pal <- light_palette(h=220, c=0.3)
# and get 10 colors from it
blues_pal(n=10)
show_col(blues_pal(n=10))
# or use the shortcut
show_col(light_colors(n=50, h=220, c=0.3))

# Determine hue from a color
blues <- light_colors(n=50, h="dodgerblue")
greens <- light_colors(n=50, h="green")
yellows <- light_colors(n=50, h="gold")
pinks <- light_colors(n=50, h="deeppink")
show_col(blues, greens, yellows, pinks)

# Perceived lightness increases similarly among hues,
# which makes the different palettes comparable
# (this would not be the case with a HSL or HSV gradient)
plot(  luminance(blues),   col=blues[40])
points(luminance(greens),  col=greens[40])
points(luminance(yellows), col=yellows[40])
points(luminance(pinks),   col=pinks[40])

# Lightness scales are good for continuous variables
# such as the elevation of the Maunga Whau volcano
image(maunga, col=light_colors(100, h=140))
contour(maunga, col=alpha("white", 0.5), add=TRUE)

persp(maunga, theta=50, phi=25, border=alpha("black", 0.3),
      col=light_map(persp_facets(maunga$z), h=140))

\dontrun{library("rgl")
persp3d(maunga, aspect=c(1,0.6,0.3), axes=FALSE, box=FALSE,
        col=light_map(maunga$z, h=140))
play3d(spin3d(axis=c(0, 0, 1), rpm=10), duration=6)
}
# With a limited number of levels, they can also work for discrete variables
attach(iris)
plot(Petal.Length, Sepal.Length, pch=19, col=light_map(Species))
legend(1, 8, legend=levels(Species), pch=19,
       col=light_colors(n=nlevels(Species)))
# but a hue-based scale is probably more appropriate (see ?hue_map)

}
\seealso{
\code{\link{luminance}} for a the computation of perceived luminance and the creation of perception-based luminance palettes.

The \code{\link{hcl}} function, on which this one is based.

Other HCL-based scales: \code{\link{chroma_scale}},
  \code{\link{hue_scale}}

Other color scales and palettes: \code{\link{brewer_scale}},
  \code{\link{chroma_scale}},
  \code{\link{cubehelix_scale}}, \code{\link{hue_scale}},
  \code{\link{inferno_scale}}, \code{\link{interp_scale}},
  \code{\link{magma_scale}}, \code{\link{plasma_scale}},
  \code{\link{viridis_scale}}
}
